# Task
Порівняйте три алгоритми сортування: злиттям, вставками та Timsort за часом виконання. Аналіз повинен бути підтверджений емпіричними даними, отриманими шляхом тестування алгоритмів на різних наборах даних. Емпірично перевірте теоретичні оцінки складності алгоритмів, наприклад, сортуванням на великих масивах. Для заміру часу виконання алгоритмів використовуйте модуль timeit.

Покажіть, що поєднання сортування злиттям і сортування вставками робить алгоритм Timsort набагато ефективнішим, і саме з цієї причини програмісти, в більшості випадків, використовують вбудовані в Python алгоритми, а не кодують самі. Зробіть висновки.


## Input data sets

Для тестування було взято набори даних у вигляді масивів із 1000 чисел та 1000 слів різної довжини

## Result:

| Type of sorting method  | Numbers results, sec  | Words results, sec  |
|           ---           |         :-:           |         :-:         |
| Insertion sort          |       1.894672        |      2.110350       |
| Merge sort              |       0.149844        |      0.152200       |
| Timsort-1 (sorted)      |       0.008579        |      0.013788       |
| Timsort-2 (sort)        |       0.006925        |      0.013483       |

За результатами замірів часу на виконання сортування можна зробити наступні висновки:

- Метод сортування вставками виявився одним із найповільніших, оскільки асимптотична складність алгоритму складає $O(n^2)$

- Метод сортування злиттям показав кращі результати, проте всеодно є повільним, оскільки асимптотична складність алгоритму складає $O(n⋅log\space n)$

- Timsort є гібридним алгоритмом сортування, який поєднує ідеї сортування злиттям та сортування вставками. Це робить Timsort досить ефективним для різних типів даних та різних розмірів масивів. В середньому випадку часова складність цього алгоритму складає $O(n⋅log\space n)$ і за рахунок адаптивності до вхідних даних та ефективності сортування великих масивів він дає найкращий результат.

В мові програмування **Python** предаставлено дві вбудовані функції для сортування вхідних даних і серед них швидшою виявляється `sort()`
